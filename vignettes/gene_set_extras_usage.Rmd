---
title: "gene_set_extras_usage"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{gene_set_extras_usage}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

We're going to load in some basic packages.  We use ```clusterProfiler``` to do the initial gene set analysis and the test data we're using is human so we're loading the ```org.Hs.eg.db``` annotation package - you'd modify that to use the package for the species you're using for your data.

We're using tidyverse for general data loading and manipulation - this isn't required but it's nice.

```{r setup, warning=FALSE}
library(geneSetExtras)
library(org.Hs.eg.db)
library(clusterProfiler)
library(tidyverse)
```


# Loading test data

The format of the data here isn't important, we just need some way to define the background and hit lists for each group.

```{r message=FALSE, warning=FALSE}
read_delim(system.file("hit_clusters.txt", package="geneSetExtras")) -> hit_data

hit_data |>
  group_by(cluster) |>
  count()
```

# Running Cluster Profiler

We need to generate an initial set of results from ```clusterProfiler```.  We're doing overlap (rather than quantitative) statistics here.  We should use the same settings for each of the tests.  It's important that we don't filter the hits to keep only significant results but get all of the data for all tested categories.

It's a good idea to limit the size of the gene sets used for the tests.  ClusterProfiler does this by default anyway.

In this instance we'll just use the GO:BP subsection.  We're just going to use all significant genes in this test, but you can be more selective.  Depending on the nature of your data it may make sense to split out upregulated and downregulated genes.

We'll calculate results just for cluster 4 to illustrate how this works.

```{r}
enrichGO(
  gene = hit_data |> filter(cluster=="cluster_4") |> pull(Gene),
  universe = hit_data |> pull(Gene),
  OrgDb = org.Hs.eg.db,
  keyType = "SYMBOL",
  pvalueCutoff = Inf,
  qvalueCutoff = Inf,
  readable = TRUE,
  ont = "BP"
) -> enrich_cluster_4

```

# Plotting

Now we have individual hits we can plot them out using a volcano plot.  It's often useful to make these interactive so that you can put them into Notebooks and mouse over individual hits to see what they are.


```{r}
volcano_plot(enrich_cluster_4, interactive=TRUE)
```




# Clustering

Next we want to do some categorical clustering to find hits which are similar in their gene content and then pick a suitable term to represent each of them.

```{r}
cluster_enrich_result(enrich_cluster_4) -> clusterered_results_cluster4
clusterered_results_cluster4
cluster_volcano_plot(clusterered_results_cluster4, interactive = TRUE)
```

# Automation

We have several clusters, so it would be nice to show the results for all of them.  This isn't specific to the package, but shows how this could be done.

```{r}
calculate_cluster_enrichment <- function(data,cluster_name) {
  enrichGO(
    gene = data |> filter(cluster==cluster_name) |> pull(Gene),
    universe = data |> pull(Gene),
    OrgDb = org.Hs.eg.db,
    keyType = "SYMBOL",
    pvalueCutoff = 1,
    qvalueCutoff = 1,
    readable = TRUE,
    ont = "BP"
  )
}

hit_data |> arrange(cluster)|> filter(!is.na(cluster)) |> distinct(cluster) |> pull(cluster) -> cluster_names

lapply(
  cluster_names,
  function(x)calculate_cluster_enrichment(hit_data,x)
) -> all_enrichment_results

names(all_enrichment_results) <- cluster_names

```

We can then plot out the results for each cluster

```{r}
for (name in cluster_names) {
  print(volcano_plot(all_enrichment_results[[name]], interactive=TRUE, title=name))
}
```

We can also generate clustered results

```{r}
lapply(
  all_enrichment_results,
  cluster_enrich_result
) -> all_clustered_hits

for (i in 1:length(cluster_names)) {
  if (! is.null(all_clustered_hits[[i]])) {
    all_clustered_hits[[i]] |>
      add_column(cluster=cluster_names[i], .before=1) -> all_clustered_hits[[i]]
    
    print(all_clustered_hits[[i]])
  }
}


```

# Comparison

Next we want to look for terms whose enrichment changes significantly between different datasets.  We can do this by passing a list of the enrichment results we want to compare.  Only terms which are in all sets can be tested, which is why it's important that the original enrichment is calculated without a pvalue filter.

\*NB There is an issue with clusterProfiler where it doesn't report categories with no overlaps in the gene set, however you set the filters.  This *may* be fixed in the latest devel version but we're waiting to see.  At the moment these results may under-represent the true hits.


```{r warning=FALSE}
compare_enrichment_results(all_enrichment_results) -> enrichment_differences

enrichment_differences |>
  filter(p.adjust<0.05)

```

We can see that these are redundant because we're using all terms to test with.

Let's pick out only the terms which were in our clustered hits and test just those.

```{r}
lapply(all_clustered_hits, function(x)x$ID) -> interesting_ids

do.call(c,interesting_ids) |> unique() -> interesting_ids

lapply(all_enrichment_results, function(x)x |> filter(ID %in% interesting_ids)) -> filtered_enrichment_results

compare_enrichment_results(filtered_enrichment_results) -> filtered_enrichment_differences

filtered_enrichment_differences |>
  filter(p.adjust<0.05)

```

Now we're down to just 48 terms which is a lot more manageable.

# Plot comparison results

We can take the comparison results and generate a heatmap which shows the enrichment levels in the different gene sets

```{r fig.height=8, fig.width=7}
plot_differential_enrichment_heatmap(
  filtered_enrichment_differences |> filter(p.adjust<0.05),
  scale=TRUE,
  log_scale = FALSE
)
```











